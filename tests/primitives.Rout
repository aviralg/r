
R version 3.3.0 (2016-05-03) -- "Supposedly Educational"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ## check that the 'internal generics' are indeed generic.
> 
> x <- structure(pi, class="testit")
> xx <- structure("OK", class="testOK")
> 
> for(f in ls(.GenericArgsEnv, all.names=TRUE))
+ {
+     cat("testing S3 generic '", f, "'\n", sep="")
+     method <- paste(f, "testit", sep=".")
+     if(f %in% "seq.int") {
+         ## note that this dispatches on 'seq'.
+         assign("seq.testit", function(...) xx, .GlobalEnv)
+         res <- seq.int(x, x)
+     } else {
+         if(length(grep("<-$", f)) > 0) {
+             assign(method, function(x, value) xx, .GlobalEnv)
+             y <- x
+             res <- eval(substitute(ff(y, value=pi), list(ff=as.name(f))))
+         } else {
+             ff <- get(f, .GenericArgsEnv)
+             body(ff) <- xx
+             assign(method, ff, .GlobalEnv)
+             res <- eval(substitute(ff(x), list(ff=as.name(f))))
+         }
+     }
+     stopifnot(res == xx)
+     rm(method)
+ }
testing S3 generic '!'
testing S3 generic '!='
testing S3 generic '%%'
testing S3 generic '%/%'
testing S3 generic '&'
testing S3 generic '*'
testing S3 generic '+'
testing S3 generic '-'
testing S3 generic '/'
testing S3 generic '<'
testing S3 generic '<='
testing S3 generic '=='
testing S3 generic '>'
testing S3 generic '>='
testing S3 generic 'Arg'
testing S3 generic 'Conj'
testing S3 generic 'Im'
testing S3 generic 'Mod'
testing S3 generic 'Re'
testing S3 generic '^'
testing S3 generic 'abs'
testing S3 generic 'acos'
testing S3 generic 'acosh'
testing S3 generic 'all'
testing S3 generic 'any'
testing S3 generic 'anyNA'
testing S3 generic 'as.character'
testing S3 generic 'as.complex'
testing S3 generic 'as.double'
testing S3 generic 'as.environment'
testing S3 generic 'as.integer'
testing S3 generic 'as.logical'
testing S3 generic 'as.numeric'
testing S3 generic 'as.raw'
testing S3 generic 'asin'
testing S3 generic 'asinh'
testing S3 generic 'atan'
testing S3 generic 'atanh'
testing S3 generic 'c'
testing S3 generic 'ceiling'
testing S3 generic 'cos'
testing S3 generic 'cosh'
testing S3 generic 'cospi'
testing S3 generic 'cummax'
testing S3 generic 'cummin'
testing S3 generic 'cumprod'
testing S3 generic 'cumsum'
testing S3 generic 'digamma'
testing S3 generic 'dim'
testing S3 generic 'dim<-'
testing S3 generic 'dimnames'
testing S3 generic 'dimnames<-'
testing S3 generic 'exp'
testing S3 generic 'expm1'
testing S3 generic 'floor'
testing S3 generic 'gamma'
testing S3 generic 'is.array'
testing S3 generic 'is.finite'
testing S3 generic 'is.infinite'
testing S3 generic 'is.matrix'
testing S3 generic 'is.na'
testing S3 generic 'is.nan'
testing S3 generic 'is.numeric'
testing S3 generic 'length'
testing S3 generic 'length<-'
testing S3 generic 'levels<-'
testing S3 generic 'lgamma'
testing S3 generic 'log'
testing S3 generic 'log10'
testing S3 generic 'log1p'
testing S3 generic 'log2'
testing S3 generic 'max'
testing S3 generic 'min'
testing S3 generic 'names'
testing S3 generic 'names<-'
testing S3 generic 'prod'
testing S3 generic 'range'
testing S3 generic 'rep'
testing S3 generic 'round'
testing S3 generic 'seq.int'
testing S3 generic 'sign'
testing S3 generic 'signif'
testing S3 generic 'sin'
testing S3 generic 'sinh'
testing S3 generic 'sinpi'
testing S3 generic 'sqrt'
testing S3 generic 'sum'
testing S3 generic 'tan'
testing S3 generic 'tanh'
testing S3 generic 'tanpi'
testing S3 generic 'trigamma'
testing S3 generic 'trunc'
testing S3 generic 'xtfrm'
testing S3 generic '|'
> 
> ## and that no others are generic
> for(f in ls(.ArgsEnv, all.names=TRUE))
+ {
+     if(f == "browser") next
+     cat("testing non-generic '", f, "'\n", sep="")
+     method <- paste(f, "testit", sep=".")
+     fx <- get(f, envir=.ArgsEnv)
+     body(fx) <- quote(return(42))
+     assign(method, fx, .GlobalEnv)
+     na <- length(formals(fx))
+     res <- NULL
+     if(na == 1)
+         res <- try(eval(substitute(ff(x), list(ff=as.name(f)))), silent = TRUE)
+     else if(na == 2)
+         res <- try(eval(substitute(ff(x, x), list(ff=as.name(f)))), silent = TRUE)
+     if(!inherits(res, "try-error") && identical(res, 42)) stop("is generic")
+     rm(method)
+ }
testing non-generic '%*%'
testing non-generic '.C'
testing non-generic '.Call'
testing non-generic '.Call.graphics'
testing non-generic '.External'
testing non-generic '.External.graphics'
testing non-generic '.External2'
testing non-generic '.Fortran'
testing non-generic '.Internal'
testing non-generic '.Primitive'
testing non-generic '.cache_class'
testing non-generic '.isMethodsDispatchOn'
testing non-generic '.primTrace'
testing non-generic '.primUntrace'
testing non-generic '.subset'
testing non-generic '.subset2'
testing non-generic 'UseMethod'
testing non-generic 'as.call'
testing non-generic 'attr'
testing non-generic 'attr<-'
testing non-generic 'attributes'
testing non-generic 'attributes<-'
testing non-generic 'baseenv'
testing non-generic 'call'
testing non-generic 'class'
testing non-generic 'class<-'
testing non-generic 'emptyenv'
testing non-generic 'enc2native'
testing non-generic 'enc2utf8'
testing non-generic 'environment<-'
testing non-generic 'expression'
testing non-generic 'forceAndCall'
testing non-generic 'gc.time'
testing non-generic 'globalenv'
testing non-generic 'interactive'
testing non-generic 'invisible'
testing non-generic 'is.atomic'
testing non-generic 'is.call'
testing non-generic 'is.character'
testing non-generic 'is.complex'
testing non-generic 'is.double'
testing non-generic 'is.environment'
testing non-generic 'is.expression'
testing non-generic 'is.function'
testing non-generic 'is.integer'
testing non-generic 'is.language'
testing non-generic 'is.list'
testing non-generic 'is.logical'
testing non-generic 'is.name'
testing non-generic 'is.null'
testing non-generic 'is.object'
testing non-generic 'is.pairlist'
testing non-generic 'is.raw'
testing non-generic 'is.recursive'
testing non-generic 'is.single'
testing non-generic 'is.symbol'
testing non-generic 'isS4'
testing non-generic 'lazyLoadDBfetch'
testing non-generic 'list'
testing non-generic 'missing'
testing non-generic 'nargs'
testing non-generic 'nzchar'
testing non-generic 'oldClass'
testing non-generic 'oldClass<-'
testing non-generic 'on.exit'
testing non-generic 'pos.to.env'
testing non-generic 'proc.time'
testing non-generic 'quote'
testing non-generic 'retracemem'
testing non-generic 'seq_along'
testing non-generic 'seq_len'
testing non-generic 'standardGeneric'
testing non-generic 'storage.mode<-'
testing non-generic 'substitute'
testing non-generic 'switch'
testing non-generic 'tracemem'
testing non-generic 'unclass'
testing non-generic 'untracemem'
> 
> 
> ## check that all primitives are accounted for in .[Generic]ArgsEnv,
> ## apart from the language elements:
> ff <- as.list(baseenv(), all.names=TRUE)
> ff <- names(ff)[vapply(ff, is.primitive, logical(1L))]
> 
> known <- c(names(.GenericArgsEnv), names(.ArgsEnv), tools::langElts)
> stopifnot(ff %in% known, known %in% ff)
> 
> 
> ## check which are not considered as possibles for S4 generic
> ff4 <- names(meth.FList <- methods:::.BasicFunsList)
> # as.double is the same as as.numeric
> S4generic <- ff %in% c(ff4, "as.double")
> notS4 <- ff[!S4generic]
> if(length(notS4))
+     cat("primitives not covered in methods:::.BasicFunsList:",
+         paste(sQuote(notS4), collapse=", "), "\n")
> stopifnot(S4generic)
> 
> # functions which are listed but not primitive
> extraS4 <- c('unlist', 'as.vector')
> ff4[!ff4 %in% c(ff, extraS4)]
character(0)
> stopifnot(ff4 %in% c(ff, extraS4))
> 
> 
> ## primitives which are not internally generic cannot have S4 methods
> ## unless specifically arranged (e.g. %*%)
> nongen_prims <- ff[!ff %in% ls(.GenericArgsEnv, all.names=TRUE)]
> ff3 <- ff4[vapply(meth.FList, function(x) is.logical(x) && !x, NA, USE.NAMES=FALSE)]
> ex <- nongen_prims[!nongen_prims %in% c("$", "$<-", "[", "[[" ,"[[<-", "[<-", "%*%", ff3)]
> if(length(ex))
+     cat("non-generic primitives not excluded in methods:::.BasicFunsList:",
+         paste(sQuote(ex), collapse=", "), "\n")
> stopifnot(length(ex) == 0)
> 
> ## Now check that (most of) those which are listed really are generic.
> require(methods)
> setClass("foo", representation(x="numeric", y="numeric"))
> xx <- new("foo",  x=1, y=2)
> S4gen <- ff4[vapply(meth.FList, is.function, NA, USE.NAMES=FALSE)]
> for(f in S4gen) {
+     g <- get(f)
+     if(!is(g, "genericFunction")) g <- getGeneric(f) # error on non-Generics.
+     ff <- args(g)
+     body(ff) <- "testit"
+     nm <- names(formals(ff))
+     ## the Summary group gives problems
+     if(nm[1] == '...') {
+         cat("skipping '", f, "'\n", sep="")
+         next
+     }
+     cat("testing '", f, "'\n", sep="")
+     setMethod(f, "foo", ff)
+     ## might have created a generic, so redo 'get'
+     stopifnot(identical(getGeneric(f)(xx), "testit"))
+ }
testing '$'
testing '$<-'
testing '['
testing '[<-'
testing '[['
testing '[[<-'
testing '%*%'
testing 'xtfrm'
testing 'c'
testing 'all'
testing 'any'
testing 'sum'
testing 'prod'
testing 'max'
testing 'min'
testing 'range'
testing 'is.matrix'
testing '>='
testing 'cosh'
testing 'cummax'
testing 'dimnames<-'
testing 'as.raw'
testing 'log2'
testing 'tan'
testing 'dim'
testing 'as.logical'
testing '^'
testing 'is.finite'
testing 'sinh'
testing 'log10'
testing 'as.numeric'
testing 'dim<-'
testing 'is.array'
testing 'tanpi'
testing 'gamma'
testing 'atan'
testing 'as.integer'
testing 'Arg'
testing 'signif'
testing 'cumprod'
testing 'cos'
testing 'length'
testing '!='
testing 'digamma'
testing 'exp'
testing 'floor'
testing 'acos'
testing 'seq.int'
testing 'abs'
testing 'length<-'
testing 'sqrt'
testing '!'
testing 'acosh'
testing 'is.nan'
testing 'Re'
testing 'tanh'
testing 'names'
testing 'cospi'
testing '&'
testing 'anyNA'
testing 'trunc'
testing 'cummin'
testing 'levels<-'
testing '*'
testing 'Mod'
testing '|'
testing 'names<-'
testing '+'
testing 'log'
testing 'lgamma'
testing 'as.complex'
testing 'asinh'
testing '-'
testing 'sin'
testing '/'
testing 'as.environment'
testing '<='
testing 'as.double'
testing 'is.infinite'
testing 'is.numeric'
testing 'rep'
testing 'round'
testing 'sinpi'
testing 'dimnames'
testing 'asin'
testing 'as.character'
testing '%/%'
testing 'is.na'
testing '<'
testing '>'
testing 'Im'
testing '%%'
testing 'trigamma'
testing '=='
testing 'cumsum'
testing 'atanh'
testing 'sign'
testing 'ceiling'
testing 'Conj'
testing 'log1p'
testing 'expm1'
testing 'unlist'
testing 'as.vector'
> 
> ## check that they do argument matching, or at least check names
> except <- c("call", "switch", ".C", ".Fortran", ".Call", ".External",
+             ".External2", ".Call.graphics", ".External.graphics",
+             ".subset", ".subset2", ".primTrace", ".primUntrace",
+             "lazyLoadDBfetch", ".Internal", ".Primitive", "^", "|",
+             "%*%", "rep", "seq.int", "forceAndCall",
+             ## these may not be enabled
+             "tracemem", "retracemem", "untracemem")
> 
> for(f in ls(.GenericArgsEnv, all.names=TRUE)[-(1:15)])
+ {
+     if (f %in% except) next
+     g <- get(f, envir = .GenericArgsEnv)
+     an <- names(formals(args(g)))
+     if(length(an) > 0 && an[1] == "...") next
+     an <- an[an != "..."]
+     a <- rep(list(NULL), length(an))
+     names(a) <- c("zZ", an[-1])
+     res <- try(do.call(f, a), silent = TRUE)
+     m <- geterrmessage()
+     if(!grepl('does not match|unused argument', m))
+         stop("failure on ", f)
+ }
> 
> for(f in ls(.ArgsEnv, all.names=TRUE))
+ {
+     if (f %in% except) next
+     g <- get(f, envir = .ArgsEnv)
+     an <- names(formals(args(g)))
+     if(length(an) > 0 && an[1] == "...") next
+     an <- an[an != "..."]
+     if(length(an)) {
+         a <- rep(list(NULL), length(an))
+         names(a) <- c("zZ", an[-1])
+     } else a <- list(zZ=NULL)
+     res <- try(do.call(f, a), silent = TRUE)
+     m <- geterrmessage()
+     if(!grepl('does not match|unused argument|requires 0|native symbol', m))
+         stop("failure on ", f)
+ }
> 
