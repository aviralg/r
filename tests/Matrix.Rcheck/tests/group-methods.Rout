
R version 3.3.0 (2016-05-03) -- "Supposedly Educational"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### Testing the group methods  --- some also happens in ./Class+Meth.R
> 
> library(Matrix)
> source(system.file("test-tools.R", package = "Matrix"))# identical3() etc
Loading required package: tools
> cat("doExtras:",doExtras,"\n")
doExtras: FALSE 
> 
> set.seed(2001)
> 
> mm <- Matrix(rnorm(50 * 7), nc = 7)
> xpx <- crossprod(mm)# -> "factors" in mm !
> round(xpx, 3) # works via "Math2"
7 x 7 Matrix of class "dpoMatrix"
       [,1]   [,2]    [,3]   [,4]   [,5]    [,6]   [,7]
[1,] 47.565 -6.382  -4.728 -9.123 16.727   1.727  2.572
[2,] -6.382 54.324  -1.016  1.032 -7.856  -0.907 -0.923
[3,] -4.728 -1.016  46.545  4.594 -2.694 -13.324 -4.899
[4,] -9.123  1.032   4.594 47.742 -3.846  -9.994 -0.052
[5,] 16.727 -7.856  -2.694 -3.846 49.438   8.762  0.372
[6,]  1.727 -0.907 -13.324 -9.994  8.762  50.182 -1.418
[7,]  2.572 -0.923  -4.899 -0.052  0.372  -1.418 44.602
> 
> y <- rnorm(nrow(mm))
> xpy <- crossprod(mm, y)
> res <- solve(xpx, xpy)
> signif(res, 4) # 7 x 1 Matrix
7 x 1 Matrix of class "dgeMatrix"
         [,1]
[1,]  0.05242
[2,] -0.17070
[3,]  0.09749
[4,] -0.02275
[5,]  0.11190
[6,]  0.13720
[7,] -0.04519
> 
> stopifnot(all(signif(res) == signif(res, 6)),
+ 	  all(round (xpx) == round (xpx, 0)))
> 
> ## exp(): component wise
> signif(dd <- (expm(xpx) - exp(xpx)) / 1e34, 3)# 7 x 7
7 x 7 Matrix of class "dsyMatrix"
       [,1]   [,2]   [,3]   [,4]   [,5]   [,6]   [,7]
[1,]  4.780 -2.800 -3.200 -3.690  5.100  4.300  0.723
[2,] -2.800  1.640  1.880  2.160 -2.990 -2.520 -0.424
[3,] -3.200  1.880  2.140  2.470 -3.420 -2.880 -0.484
[4,] -3.690  2.160  2.470  2.850 -3.940 -3.320 -0.558
[5,]  5.100 -2.990 -3.420 -3.940  5.450  4.590  0.772
[6,]  4.300 -2.520 -2.880 -3.320  4.590  3.870  0.651
[7,]  0.723 -0.424 -0.484 -0.558  0.772  0.651  0.109
> 
> validObject(xpx)
[1] TRUE
> validObject(xpy)
[1] TRUE
> validObject(dd)
[1] TRUE
> 
> ## "Math" also, for log() and [l]gamma() which need special treatment
> stopifnot(identical(exp(res)@x, exp(res@x)),
+           identical(log(abs(res))@x, log(abs((res@x)))),
+           identical(lgamma(res)@x, lgamma(res@x)))
> 
> 
> ###--- sparse matrices ---------
> 
> m <- Matrix(c(0,0,2:0), 3,5)
> (mC <- as(m, "dgCMatrix"))
3 x 5 sparse Matrix of class "dgCMatrix"
              
[1,] . 1 . . 2
[2,] . . 2 . 1
[3,] 2 . 1 . .
> sm <- sin(mC)
> stopifnot(class(sm) == class(mC), class(mC) == class(mC^2),
+           dim(sm) == dim(mC),
+           class(0 + 100*mC) == class(mC),
+           all.equal(0.1 * ((0 + 100*mC)/10), mC),
+           all.equal(sqrt(mC ^ 2), mC),
+           all.equal(m^m, mC^mC),
+           identical(mC^2, mC * mC),
+           identical(mC*2, mC + mC)
+           )
> 
> x <- Matrix(rbind(0,cbind(0, 0:3,0,0,-1:2,0),0))
> x # sparse
6 x 6 sparse Matrix of class "dgCMatrix"
                 
[1,] . . . .  . .
[2,] . . . . -1 .
[3,] . 1 . .  . .
[4,] . 2 . .  1 .
[5,] . 3 . .  2 .
[6,] . . . .  . .
> (x2 <- x + 10*t(x))
6 x 6 sparse Matrix of class "dgCMatrix"
                    
[1,] .  .  .  .  . .
[2,] .  . 10 20 29 .
[3,] .  1  .  .  . .
[4,] .  2  .  .  1 .
[5,] . -7  . 10 22 .
[6,] .  .  .  .  . .
> stopifnot(is(x2, "sparseMatrix"),
+           identical(x2, t(x*10 + t(x))),
+ 	  identical(x, as((x + 10) - 10, class(x))))
> 
> (px <- Matrix(x^x - 1))#-> sparse again
6 x 6 sparse Matrix of class "dgCMatrix"
                  
[1,] .  . . .  . .
[2,] .  . . . -2 .
[3,] .  . . .  . .
[4,] .  3 . .  . .
[5,] . 26 . .  3 .
[6,] .  . . .  . .
> stopifnot(px@i == c(3,4,1,4),
+           px@x == c(3,26,-2,3))
> 
> ## From: "Florent D." .. Thu, 23 Feb 2012 -- bug report
> ##---> MM:  Make a regression test:
> tst <- function(n, i = 1) {
+     stopifnot(i >= 1, n >= i)
+     D <- .sparseDiagonal(n)
+     ee <- numeric(n) ; ee[i] <- 1
+     stopifnot(all(D - ee == diag(n) - ee),
+               all(D * ee == diag(n) * ee),
+               all(ee - D == ee - diag(n)),
+               {C <- (ee / D == ee / diag(n)); all(is.na(C) | C)},
+               TRUE)
+ }
> nn <- if(doExtras) 27 else 7
> tmp <- sapply(1:nn, tst) # failed in Matrix 1.0-4
> i <- sapply(1:nn, function(i) sample(i,1))
> tmp <- mapply(tst, n= 1:nn, i= i)# failed too
> 
> (lsy <- new("lsyMatrix", Dim = c(2L,2L), x=c(TRUE,FALSE,TRUE,TRUE)))
2 x 2 Matrix of class "lsyMatrix"
     [,1] [,2]
[1,] TRUE TRUE
[2,] TRUE TRUE
> nsy <- as(lsy, "nMatrix")
> (t1  <- new("ltrMatrix", Dim = c(1L,1L), x = TRUE))
1 x 1 Matrix of class "ltrMatrix"
     [,1]
[1,] TRUE
> (t2  <- new("ltrMatrix", Dim = c(2L,2L), x = rep(TRUE,4)))
2 x 2 Matrix of class "ltrMatrix"
     [,1]  [,2] 
[1,]  TRUE  TRUE
[2,]     .  TRUE
> stopifnot(all(lsy), # failed in Matrix 1.0-4
+           all(nsy), #  dito
+ 	  all(t1),  #   "
+           ## ok previously (all following):
+           !all(t2),
+ 	  all(sqrt(lsy) == 1))
> dsy <- lsy+1
> 
> showProc.time()
Time elapsed:  0.24 0.004 0.243 
> set.seed(111)
> local({
+     for(i in 1:(if(doExtras) 20 else 5)) {
+         M <- rspMat(n=1000, 200, density = 1/20)
+         v <- rnorm(ncol(M))
+         m <- as(M,"matrix")
+         stopifnot(all(t(M)/v == t(m)/v))
+         cat(".")
+     }});cat("\n")
.....
> 
> ## Now just once, with a large such matrix:
> local({
+     n <- 100000; m <- 30000
+     AA <- rspMat(n, m, density = 1/20000)
+     v <- rnorm(m)
+     st <- system.time({
+         BB <- t(AA)/v # should happen *fast*
+         stopifnot(dim(BB) == c(m,n), is(BB, "sparseMatrix"))
+     })
+     str(BB)
+     print(st)
+     if(Sys.info()[["sysname"]] == "Linux") {
+         mips <- as.numeric(sub(".*: *", '',
+                                grep("bogomips", readLines("/proc/cpuinfo"),
+                                     value=TRUE)[[1]]))
+         stopifnot(st[1] < 1000/mips)# ensure there was no gross inefficiency
+     }
+ })
Formal class 'dgCMatrix' [package "Matrix"] with 6 slots
  ..@ i       : int [1:150000] 12670 16811 20412 8107 12507 25011 25802 5083 6142 1708 ...
  ..@ p       : int [1:100001] 0 3 7 9 10 12 15 15 16 17 ...
  ..@ Dim     : int [1:2] 30000 100000
  ..@ Dimnames:List of 2
  .. ..$ : NULL
  .. ..$ : NULL
  ..@ x       : num [1:150000] 509566 46384 -119334 -39561 -57009 ...
  ..@ factors : list()
   user  system elapsed 
  0.012   0.000   0.010 
> 
> 
> ###----- Compare methods ---> logical Matrices ------------
> l3 <- upper.tri(matrix(, 3, 3))
> (ll3 <- Matrix(l3))
3 x 3 sparse Matrix of class "ltCMatrix"
          
[1,] . | |
[2,] . . |
[3,] . . .
> dt3 <- (99* Diagonal(3) + (10 * ll3 + Diagonal(3)))/10
Note: method with signature 'dMatrix#ddiMatrix' chosen for function '+',
 target signature 'dtCMatrix#ddiMatrix'.
 "triangularMatrix#diagonalMatrix" would also be valid
Note: method with signature 'ddiMatrix#dMatrix' chosen for function '+',
 target signature 'ddiMatrix#dtCMatrix'.
 "diagonalMatrix#triangularMatrix" would also be valid
> (dsc <- crossprod(ll3))
3 x 3 sparse Matrix of class "dsCMatrix"
          
[1,] . . .
[2,] . 1 1
[3,] . 1 2
> stopifnot(identical(ll3, t(t(ll3))),
+ 	  identical(dsc, t(t(dsc))))
> stopifnotValid(ll3, "ltCMatrix")
> stopifnotValid(dsc, "dsCMatrix")
> stopifnotValid(dsc + 3 * Diagonal(nrow(dsc)), "dsCMatrix")
> stopifnotValid(dt3, "triangularMatrix")    # remained triangular
> stopifnotValid(dt3 > 0, "triangularMatrix")# ditto
> 
> 
> (lm1 <- dsc >= 1) # now ok
3 x 3 sparse Matrix of class "lsCMatrix"
          
[1,] . . .
[2,] . | |
[3,] . | |
> (lm2 <- dsc == 1) # now ok
3 x 3 sparse Matrix of class "lsCMatrix"
          
[1,] . . .
[2,] . | |
[3,] . | :
> nm1 <- as(lm1, "nMatrix")
> (nm2 <- as(lm2, "nMatrix"))
3 x 3 sparse Matrix of class "nsCMatrix"
          
[1,] . . .
[2,] . | |
[3,] . | |
> 
> stopifnot(validObject(lm1), validObject(lm2),
+           validObject(nm1), validObject(nm2),
+           identical(dsc, as(dsc * as(lm1, "dMatrix"), "dsCMatrix")))
> 
> crossprod(lm1) # lm1: "lsC*"
3 x 3 sparse Matrix of class "dsCMatrix"
          
[1,] . . .
[2,] . 2 2
[3,] . 2 2
> cnm1 <- crossprod(nm1)
> stopifnot(is(cnm1, "symmetricMatrix"), ## whereas the %*% is not:
+ 	  Q.eq(cnm1, nm1 %*% nm1))
> dn1 <- as(nm1, "denseMatrix")
> stopifnot(all(dn1 == nm1))
> 
> dsc[2,3] <- NA ## now has an NA (and no longer is symmetric)
> ##          ----- and "everything" is different
> ## also add "non-structural 0":
> dsc@x[1] <- 0
> dsc
3 x 3 sparse Matrix of class "dgCMatrix"
           
[1,] . .  .
[2,] . 0 NA
[3,] . 1  2
> dsc/ 5
3 x 3 sparse Matrix of class "dgCMatrix"
              
[1,] . .   .  
[2,] . 0.0  NA
[3,] . 0.2 0.4
> dsc + dsc
3 x 3 sparse Matrix of class "dgCMatrix"
           
[1,] . .  .
[2,] . 0 NA
[3,] . 2  4
> dsc - dsc
3 x 3 sparse Matrix of class "dgCMatrix"
           
[1,] . .  .
[2,] . 0 NA
[3,] . 0  0
> dsc + 1 # -> no longer sparse
3 x 3 Matrix of class "dgeMatrix"
     [,1] [,2] [,3]
[1,]    1    1    1
[2,]    1    1   NA
[3,]    1    2    3
> Tsc <- as(dsc, "TsparseMatrix")
> dsc. <- drop0(dsc)
> stopifnot(identical(dsc., Matrix((dsc + 1) -1)),
+ 	  identical(as(-Tsc,"CsparseMatrix"), (-1) * Tsc),
+ 	  identical(-dsc., (-1) * dsc.),
+ 	  identical3(-Diagonal(3), Diagonal(3, -1), (-1) * Diagonal(3)),
+ 	  identical(dsc., Matrix((Tsc + 1) -1)), # ok (exact arithmetic)
+ 	  Q.eq(0 != dsc, dsc != Matrix(0, 3, 3)),
+ 	  Q.eq(0 != dsc, dsc != c(0,0)) # with a warning ("not multiple ..")
+ 	  )
Warning message:
In Matrix(e2, nrow = d[1], ncol = d[2]) :
  data length [2] is not a sub-multiple or multiple of the number of rows [3]
> str(lm1 <- dsc >= 1) # now ok (NA in proper place, however:
Formal class 'lgCMatrix' [package "Matrix"] with 6 slots
  ..@ i       : int [1:4] 1 2 1 2
  ..@ p       : int [1:4] 0 0 2 4
  ..@ Dim     : int [1:2] 3 3
  ..@ Dimnames:List of 2
  .. ..$ : NULL
  .. ..$ : NULL
  ..@ x       : logi [1:4] FALSE TRUE NA TRUE
  ..@ factors : list()
> lm1 ## NA used to print as ' ' , now 'N'
3 x 3 sparse Matrix of class "lgCMatrix"
          
[1,] . . .
[2,] . : N
[3,] . | |
> (lm2 <- dsc == 1)# ditto
3 x 3 sparse Matrix of class "lgCMatrix"
          
[1,] . . .
[2,] . : N
[3,] . | :
> stopifnot(identical(crossprod(lm1),# "lgC": here works!
+                     crossprod(as(lm1, "dMatrix"))),
+           identical(lm2, lm1 & lm2),
+ 	  identical(lm1, lm1 | lm2))
> 
> ddsc <- kronecker(Diagonal(7), dsc)
Note: method with signature 'diagonalMatrix#Matrix' chosen for function 'kronecker',
 target signature 'ddiMatrix#dgCMatrix'.
 "ANY#sparseMatrix" would also be valid
Note: method with signature 'dsparseMatrix#dsparseMatrix' chosen for function 'kronecker',
 target signature 'dtTMatrix#dgCMatrix'.
 "TsparseMatrix#sparseMatrix" would also be valid
> isValid(ddv <- rowSums(ddsc, sparse=TRUE), "sparseVector")
[1] TRUE
> sv <- colSums(kC <- kronecker(mC,kronecker(mC,mC)), sparse=TRUE)
Note: method with signature 'dsparseMatrix#dsparseMatrix' chosen for function 'kronecker',
 target signature 'dgCMatrix#dgTMatrix'.
 "sparseMatrix#TsparseMatrix" would also be valid
> EQ <- ddv == rowSums(ddsc)
> na.ddv <- is.na(ddv)
> sM <- Matrix(pmax(0, round(rnorm(50*15, -1.5), 2)), 50,15)
> stopifnot(sv == colSums(kC), is.na(as.vector(ddv)) == na.ddv,
+           isValid(sM/(-7:7), "CsparseMatrix"),
+ 	  all(EQ | na.ddv))
> 
> ## Subclasses (!)
> setClass("m.spV", contains = "dsparseVector")
> (m.ddv <- as(ddv, "m.spV"))
sparse vector (nnz/length = 14/21) of class "m.spV"
 [1]  . NA  3  . NA  3  . NA  3  . NA  3  . NA  3  . NA  3  . NA  3
> stopifnot(all.equal(m.ddv, ddv))# failed
> setClass("m.dgC", contains = "dgCMatrix")
> (m.mC <- as(mC, "m.dgC"))
3 x 5 sparse Matrix of class "m.dgC"
              
[1,] . 1 . . 2
[2,] . . 2 . 1
[3,] 2 . 1 . .
> stopifnot(all(m.mC == mC))
> 
> ## Just for print "show":
> z <- round(rnorm(77), 2)
> z[sample(77,10)] <- NA
> (D <- Matrix(z, 7)) # dense
7 x 11 Matrix of class "dgeMatrix"
      [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9] [,10] [,11]
[1,] -0.12  0.24  0.22  0.61  1.50  0.73 -0.53 -0.18  0.41    NA    NA
[2,]  0.69  0.40    NA -1.73 -0.84    NA  0.20 -1.15 -0.13  0.26 -0.02
[3,]  1.12 -0.55  0.92  1.55  0.78 -0.49 -0.65  1.05 -1.77 -1.42    NA
[4,]  1.41 -0.47    NA  2.31  0.99 -0.19 -1.17 -0.97 -1.14 -1.98    NA
[5,]  0.35  0.07  0.91 -0.60  0.02 -0.86  2.83  0.65  0.50 -0.86 -1.79
[6,] -2.77 -1.81 -1.00  0.25    NA  1.58  1.26 -0.21  0.30  0.21 -1.20
[7,]  0.84    NA    NA  0.48 -0.46  0.73  0.53  1.42 -0.48 -0.46  0.00
> z[sample(77,15)] <- 0
> (D <- Matrix(z, 7)) # sparse
7 x 11 Matrix of class "dgeMatrix"
      [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9] [,10] [,11]
[1,] -0.12  0.24  0.22  0.61  1.50  0.73 -0.53  0.00  0.00    NA    NA
[2,]  0.69  0.00    NA -1.73 -0.84    NA  0.20 -1.15  0.00  0.26 -0.02
[3,]  1.12 -0.55  0.92  0.00  0.78 -0.49 -0.65  1.05  0.00  0.00    NA
[4,]  1.41  0.00    NA  2.31  0.00 -0.19 -1.17 -0.97 -1.14 -1.98  0.00
[5,]  0.35  0.07  0.91 -0.60  0.02 -0.86  2.83  0.00  0.50  0.00 -1.79
[6,] -2.77 -1.81 -1.00  0.00    NA  1.58  1.26 -0.21  0.30  0.21 -1.20
[7,]  0.00  0.00    NA  0.48 -0.46  0.73  0.53  1.42 -0.48 -0.46  0.00
> abs(D) >= 0.5       # logical sparse
7 x 11 Matrix of class "lgeMatrix"
      [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9] [,10] [,11]
[1,] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE    NA    NA
[2,]  TRUE FALSE    NA  TRUE  TRUE    NA FALSE  TRUE FALSE FALSE FALSE
[3,]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE    NA
[4,]  TRUE FALSE    NA  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE
[5,] FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE
[6,]  TRUE  TRUE  TRUE FALSE    NA  TRUE  TRUE FALSE FALSE FALSE  TRUE
[7,] FALSE FALSE    NA FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE
> 
> 
> ## For the checks below, remove some and add a few more objects:
> rm(list= ls(pat="^.[mMC]?$"))
> D3 <- Diagonal(x=4:2); L7 <- Diagonal(7) > 0
> T3 <- Diagonal(3) > 0; stopifnot(T3@diag == "U") # "uni-diagonal"
> validObject(xpp <- pack(round(xpx,2)))
[1] TRUE
> validObject(dtp <- pack(as(dt3, "denseMatrix")))
[1] TRUE
> lsp <- xpp > 0
> isValid(lsC <- as(lsp, "sparseMatrix"), "lsCMatrix")
[1] TRUE
> 
> showProc.time()
Time elapsed:  0.58 0.016 0.596 
> if(!doExtras && !interactive()) q("no") ## (saving testing time)
> proc.time()
   user  system elapsed 
  1.548   0.044   1.590 
